function [ cellOutput ] = rachSanMarkAnalysis( cellInput )
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%RACHSANMARKANALYSIS Analyze Mark Data from Rachwani-Santamaria paradigm
%   This function calculates mark data analyses and other meta-data from
%   the mark data generated by the Rachwani-Santamaria data collection
%   paradigm.
%
%   Due to Legacy requirements, Mark Data files do not obey the standard
%   ordering observed in other GKF Files.  Mark Data Files have all
%   Position data up front in the first 12 columns, and are then followed
%   by all rotational matrices, should they ever be necessary.
%
%   As such, the calculations below assume the following matrix indices
%   POSITION
%   Sensor 1 x,y,z -- 1,2,3
%   Sensor 2 x,y,z -- 4,5,6
%   Sensor 3 x,y,z -- 7,8,9
%   Sensor 4 x,y,z -- 10,11,12
%   ROTATION MATRICES
%   Sensor 1 -- 13:21
%   Sensor 2 -- 22:30
%   Sensor 3 -- 31:39
%   Sensor 4 -- 40:48
%
%   This function also transforms the position data given to it, generating
%   virtual position markers based on the marker data.  For legacy reasons,
%   these virtual position data markers will be inserted directly into the
%   data set.
%   Virtual Head Center Of Mass -- Inserted Between Sensors 1 and 2
%   Virtual Trunk Center Of Mass -- Inserted Between Sensors 2 and 3
%
%
%Author: Wayne Manselle
%Date: November 2014
%
%Inputs:
%   cellInput -- The collected input sent to the mark function.  In the
%   case of the rachSanMarkAnalysis function, the cell input is comprised
%   of two components: 
%       1 -- The collection of Mark Data
%       2 -- The collection of Position Data to be modified with the
%       virtual positional and rotational matrices.
%
%Outputs:
%   cellOutput -- The collected output of the mark function.  In the case
%   of the rachSanMarkAnalysis fuction, the cell output is comprised of
%   two components:
%       1 -- The collection of metadata produced by the function.  This
%       metadata is comprised of three components:
%               A -- RPI of the Head
%               B -- RPI of the Trunk
%               C -- Data related to the composition and location of the
%               center of Base of Support and Center of Trunk
%               D -- Max Head Height
%               E -- Max Trunk Height
%       2 -- The corrected kinematic data to be used.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Retrieve Mark and Kinematic Data from the Cell Array Input
markData = cellInput{1};
kinData = cellInput{2};

%Prep the Output Variables
rpiHead = zeros(1,3);
rpiTrunk = zeros(1,3);
centerData = zeros(4,9);

%Repeatedly Used Scratch Variable
centerXYZ = zeros(1,3);

%Calculate the RPI Data using data from Mark 3.

%%%%Original Code%%%%
%Initialize transitatory matrices.
tragCenter = zeros(1,3);
vHdCenter = zeros(1,3);
matHdCenter = zeros(3,3);

%Calculate the trageus center by getting the absolute value
%of the difference between the trageus locations.  
%This data is pulled from the X,Y,Z data from sensors 3 and 4.
tragCenter(1)=(markData(3,7) + markData(3,10))/2;
tragCenter(2)=(markData(3,8) + markData(3,11))/2;
tragCenter(3)=(-markData(3,9) + markData(3,12))/2;

%Subtract the head marker's location from the trageus
%center's location to get the virtual head center.
vHdCenter(1) = tragCenter(1) - markData(3,1);
vHdCenter(2) = tragCenter(2) - markData(3,2);
vHdCenter(3) = tragCenter(3) - markData(3,3);

%Assemble Matrix of the Head Marker
matHdCenter(1,:) = markData(3,13:15);
matHdCenter(2,:) = markData(3,16:18);
matHdCenter(3,:) = markData(3,19:21);

%Finally, calculate RPI.
rpiHead(:) = matHdCenter' * vHdCenter';

%Marks 5 and 6 are used to determine the center of the base of support as
%positioned on the body.
for mark=1:2
    %Get the Component Data from Sensors 3 and 4
    centerData(mark,1:3) = [markData(mark+4,7) markData(mark+4,8) markData(mark+4,9)];
    centerData(mark,4:6) = [markData(mark+4,10) markData(mark+4,11) markData(mark+4,12)];
    %Calculate the Center from the components
    centerXYZ(1) = (centerData(mark,1) + centerData(mark,4))/2;
    centerXYZ(2) = (centerData(mark,2) + centerData(mark,5))/2;
    centerXYZ(3) = (centerData(mark,3) + centerData(mark,6))/2;
    %Get the Calculated Center Data
    centerData(mark,7:9) = centerXYZ(:);
end

%Find the midpoint of the midpoints to determine Center of Base of Support
centerData(3,7) = (centerData(1,7) + centerData(2,7))/2;
centerData(3,8) = (centerData(1,8) + centerData(2,8))/2;
centerData(3,9) = (centerData(1,9) + centerData(2,9))/2;

%Mark 7 is used to determine the center of the trunk and its RPI data.

%Get the Component Data. Here we are getting the columns
%corresponding to Sensor 4 and Sensor 2.
centerData(4,1:3) = [markData(7,10) markData(7,11) markData(7,12)];
centerData(4,4:6) = [markData(7,4) markData(7,5) markData(7,6)];

%Calculate the Center from the components
centerXYZ(1) = (abs(centerData(4,1) - centerData(4,4))/2)+(min(centerData(4,1),centerData(4,4)));
centerXYZ(2) = (abs(centerData(4,2) - centerData(4,5))/2)+(min(centerData(4,2),centerData(4,5)));
centerXYZ(3) = (abs(centerData(4,3) - centerData(4,6))/2)+(min(centerData(4,3),centerData(4,6)));

%Get the Calculated Center Data
centerData(4,7:9) = centerXYZ(:);

%Subtract the C7 marker's location from the midpoint between C7
%and sternal notch to get the vector.
vTrunk(1) = centerXYZ(1) - markData(7,4);
vTrunk(2) = centerXYZ(2) - markData(7,5);
vTrunk(3) = centerXYZ(3) - markData(7,6);

%Assemble Rotational Matrix of the C7 Marker
matC7(1,:) = markData(7,22:24);
matC7(2,:) = markData(7,25:27);
matC7(3,:) = markData(7,28:30);

%Finally, calculate RPI_TrunkData.  
rpiTrunk(:) = matC7' * vTrunk';

%Now generate the virtual position points and correct for center of base of
%support.
virtHdCOMPos = zeros(size(kinData(:,1:3)));
virtTkCOMPos = zeros(size(kinData(:,4:6)));

%Pre-allocate the corrected Kinematic Data Structure, adding 24 columns to
%handle the virtual marker's position and rotational matrix data
corrKinData = zeros(size(kinData,1),size(kinData,2)+24);

for vrInd = 1:size(kinData(:,1:3),1)
    %Generate virtual marker positions
    virtHdCOMPos(vrInd,1:3) = (matHdCenter * rpiHead')' + kinData(vrInd,1:3);
    virtTkCOMPos(vrInd,1:3) = (matC7 * rpiTrunk')' + kinData(vrInd,4:6);
    
    %Build the next row of data, and correct for Base of Support Offset
    corrKinData(vrInd,:) = horzcat((kinData(vrInd,1:3) - centerData(3,7:9)), kinData(vrInd,4:12),...
    (virtHdCOMPos(vrInd,:) - centerData(3,7:9)),kinData(vrInd,4:12),...
    (kinData(vrInd,13:15) - centerData(3,7:9)),kinData(vrInd,16:24),...
    (virtTkCOMPos(vrInd,:) - centerData(3,7:9)),kinData(vrInd,16:24),...
    (kinData(vrInd,25:27) - centerData(3,7:9)),kinData(vrInd,28:36),...
    (kinData(vrInd,37:39) - centerData(3,7:9)),kinData(vrInd,40:end));
end

%Put together Output Variables
metaData = cell(1,3);
metaData(1) = {rpiHead};
metaData(2) = {rpiTrunk};
metaData(3) = {centerData};
%Max Head and Trunk Height
metaData(4) = {max(corrKinData(:,15))};
metaData(5) = {max(corrKinData(:,39))};

cellOutput = cell(1,2);
cellOutput{1} = metaData;
cellOutput{2} = corrKinData;

end